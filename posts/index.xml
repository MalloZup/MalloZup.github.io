<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Dario Maiocchi</title>
    <link>https://mallozup.github.io/posts/</link>
    <description>Recent content in Posts on Dario Maiocchi</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 07 Jan 2021 14:44:22 +0100</lastBuildDate>
    
	<atom:link href="https://mallozup.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Learning how to learn, a life long challange</title>
      <link>https://mallozup.github.io/posts/learning-how-to-learn/</link>
      <pubDate>Thu, 07 Jan 2021 14:44:22 +0100</pubDate>
      
      <guid>https://mallozup.github.io/posts/learning-how-to-learn/</guid>
      <description>Learning how to Learn Facts: Sport/exercise. Neuroscience confirm that exercise make you smart. Start do sport. (See the focused vs diffuse mode of brain for the rationale, next section.)
Be active learner instead of passive learner. Engage with material, people, Recall, test your learning, create something with the abstract theories you are learning. This will create neurostructure with the material and the concepts you are learning, instead of memorizing them, or just view them as passive observator.</description>
    </item>
    
    <item>
      <title>an humble gRPC rate-limiting tutorial</title>
      <link>https://mallozup.github.io/posts/grpc-ratelimiting/</link>
      <pubDate>Wed, 30 Dec 2020 14:36:38 +0100</pubDate>
      
      <guid>https://mallozup.github.io/posts/grpc-ratelimiting/</guid>
      <description>Summary:  1) Rationale 2) Live Demo 3) Some Code details 4) Disclaimer  1) Rationale: Today I want to show you a possible solution, to a well-known problem when dealing with backend APIs or/and WEB applications.
The problem: imagine today is a special day, like 1 week before Christmas. Your servers will probably reach an abnormal higher number of client request.
If you don&amp;rsquo;t have a mechanism for limiting the number of requests, your servers resources, your servers or/and application will crash, or having a bad behaviour which will be probably will led to a massive service outage.</description>
    </item>
    
    <item>
      <title>Things and projects learned within Thanos opensource project</title>
      <link>https://mallozup.github.io/posts/things-learned-with-thanos/</link>
      <pubDate>Tue, 22 Dec 2020 12:26:17 +0100</pubDate>
      
      <guid>https://mallozup.github.io/posts/things-learned-with-thanos/</guid>
      <description>Things learned with Thanos opensource proejct Recently I started working and learning thanos concepts just for fun and as opensource individual (during my free time).
This blogpost just summarize shortly some things I have learned, during some few days.
 0) if you want to try out thanos check: https://katacoda.com/thanos/courses/thanos/1-globalview
 1) Prometheus mixins and jsonnet concepts
 2) Grpc protocol and middlewares
 3) Rate limiting algorithm
 4) Prometheus internals</description>
    </item>
    
    <item>
      <title>Saltstack standalone formula: resilency and zero error</title>
      <link>https://mallozup.github.io/posts/salt-static-types/</link>
      <pubDate>Fri, 02 Oct 2020 20:08:03 +0200</pubDate>
      
      <guid>https://mallozup.github.io/posts/salt-static-types/</guid>
      <description>Saltstack Static types for standalone formula. Rationale: Recently I wanted to run a formula saltstack as standalone. (without any master/minion) and locally.
Running a formula is quite complex if you don&amp;rsquo;t know how to run it.
I do think that if you consider zypper, salt-call is the next layer up to zypper, in term of abstraction and context.
That is why i was motivated to create an simple CLI for my specific context;</description>
    </item>
    
    <item>
      <title>Self-healing systems: Instrumenting applications with Prometheus alerts</title>
      <link>https://mallozup.github.io/posts/selfhealing-systems-part2/</link>
      <pubDate>Sun, 27 Sep 2020 15:46:59 +0200</pubDate>
      
      <guid>https://mallozup.github.io/posts/selfhealing-systems-part2/</guid>
      <description>Selfhealing systems part 2: In the previous blog post I covered how to use Prometheus as basis for building selfhealing systems. (https://mallozup.github.io/posts/self-healing-systems-with-prometheus/)
Today I will explain how you can instrument your application, creating alert, which are fired inside production code and then handle them automatically, without human intervention.
Instrumenting your application with Prometheus alerts A selfhealing system need to have, among others components, 2 components:
 1) a &amp;ldquo;reactor&amp;rdquo; or alert-handeler component which handle automatically alerts and react with your domain logic on this alerts.</description>
    </item>
    
    <item>
      <title>Intelligent systems with prometheus</title>
      <link>https://mallozup.github.io/posts/self-healing-systems-with-prometheus/</link>
      <pubDate>Mon, 21 Sep 2020 18:19:18 +0200</pubDate>
      
      <guid>https://mallozup.github.io/posts/self-healing-systems-with-prometheus/</guid>
      <description>Intelligent systems with prometheus Cloud native systems are complex systems. Hardware fails, software has bugs, things get wrong.
In this scenario Prometheus offer a valid help for creating more resilient systems, whichg can auto-heal themself in certains circustances.
In this demo I will show how you can use the Prometheus stack to improve your systems.
What do you need for getting the pattern I do simplify lot of things assuming you can setup prometehus/alertmanager and you can create an alert via prometehus ( plenty of doc upstream are avail)</description>
    </item>
    
    <item>
      <title>Monitoring an HA Cluster</title>
      <link>https://mallozup.github.io/posts/monitoring-ha-cluster/</link>
      <pubDate>Fri, 13 Sep 2019 16:59:40 +0200</pubDate>
      
      <guid>https://mallozup.github.io/posts/monitoring-ha-cluster/</guid>
      <description>Version 0.0.1: This blog is incremental. Each version will bring new features in term of content.
HA Cluster intro https://clusterlabs.org/
Clusterlabs is in production since 1999 and it still works. The difference between other nowdays cluster is that is a resource cluster.
A resource can be for example Apache. A resource doesn&amp;rsquo;t need to be in a container, it can but can be in a bare metal host etc.</description>
    </item>
    
    <item>
      <title>Systems Design: 01 nREPL clojure</title>
      <link>https://mallozup.github.io/posts/systems-draw-01-nrepl/</link>
      <pubDate>Sun, 25 Aug 2019 14:13:26 +0200</pubDate>
      
      <guid>https://mallozup.github.io/posts/systems-draw-01-nrepl/</guid>
      <description>Meta: This blog post is based on commit: https://github.com/nrepl/nrepl/commit/21a3200a5dee737efa0dca7529cd2b69b41c7644 This the 2nd entry of unconventional systems design.
nREPL The nREPL consist of different (github) repositories: the nREPL server, the clients and middleware extensions.
The &amp;ldquo;unconventional map&amp;rdquo; I draw for nREPL it should give most of the key ponts to understand nREPL general architecture. It doesn&amp;rsquo;t cover all the details and I think one could draw different maps for the specifics components interactions which will go more in details.</description>
    </item>
    
    <item>
      <title>Heartofclojure</title>
      <link>https://mallozup.github.io/posts/heartofclojure/</link>
      <pubDate>Sat, 10 Aug 2019 18:39:11 +0200</pubDate>
      
      <guid>https://mallozup.github.io/posts/heartofclojure/</guid>
      <description>A courageous conference? In the train to Belgium, I was asking me: What is to be a developer? I&amp;rsquo;m a remote developer but during the years, my answer to this question has always changed; like when you revisit a city in different times of your life.
With a superficial mindset, people might think that a developer is just a person who write code, and our industry it might push people to think like this.</description>
    </item>
    
    <item>
      <title>Systems Design: 00-Terraform-libvirt</title>
      <link>https://mallozup.github.io/posts/systems-draw-00/</link>
      <pubDate>Thu, 08 Aug 2019 18:25:23 +0200</pubDate>
      
      <guid>https://mallozup.github.io/posts/systems-draw-00/</guid>
      <description>The first 00 unconventional series of Software design.
Meta:  Project: https://github.com/dmacvicar/terraform-provider-libvirt Description:Terraform provider to provision infrastructure with Linux&amp;rsquo;s KVM using libvirt) Language: golang  I&amp;rsquo;m attempting to draw Software architecture in a unconventional way, because I think describing software with predifined models is somehow restrictive. Here is an humble tentative:
Analysis: We have 3 layers of abstraction:
First perspective (number 1 in the picture), the data model and flow in highlevel manner:  terraform-libvirt take as input an HCL file, and transform it in XML format which will then consumed by Libvirt.</description>
    </item>
    
  </channel>
</rss>